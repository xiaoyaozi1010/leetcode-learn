// 上次记录的不小心丢了，重新记录一份吧。
/**
 * 动态规划五部曲
 * 1. 确定dp数组(dp table)以及下标的含义 
 * 2. 确定递推公式
 * 3. dp数组如何初始化
 * 4. 确定遍历顺序
 * 5. 举例推导dp数组
 */

/**
 * 509. @斐波那契数列
 * 斐波那契数列是指，第1项是0，第二项是1，此后，后面的每一项都是前面两项的和，使用动态规划在O(n) 内可解决。
 */
function fib (n) {
    // 1. 状态定义，确定数组含义, dp[i] 表示到第 i 项的值；
    const dp = []; 
    // 2. 状态转移方程，确定地推公式。根据定义可知，dp[i] = dp[i - 1] + dp[i - 2];
    // 3. 初始化状态，根据定义可知，dp[0] = 0, dp[1] = 1; dp[2] = dp[1] + dp[0]; 前两项的和
    dp.push(0, 1);
    // 4. 确定遍历顺序，从第几位开始遍历，或者从哪个方向开始遍历。
    // for (let i = 2; i <= n; i++) {
    //     dp[i] = dp[i - 1] + dp[i - 2];
    // }
    // return dp[n];
    // 从数组dp上看，dp其实只使用了dp[i - 1] 和 dp[i - 2] 这两项，对于其他的项，用过一次之后就没再使用，占用了无意义的空间。
    // 所以可以将空间占用固定到常量，不需要根据n的值而变化
    let res = 0;
    for (let i = 2; i <= n; i++) {
        res = dp[0] + dp[1]
        dp[0] = dp[1];
        dp[1] = res;
    }
    return res;
}

/**
 * 70. @爬楼梯
 * 假设正在爬楼梯，要爬n个楼梯才会到达楼顶。每次可以爬 1 个或者 2 个台阶，在一个具有 n 个台阶的楼梯，有多少种方法才能爬到楼顶
 * 输入：2
 * 输出：2
 * 解释：有两种方法爬到楼顶
 *  1. 1 阶 + 1 阶
 *  2. 2 阶
 * 输入：3
 * 输出：3
 * 解释：有三种方法爬到楼顶
 *  1. 1阶 + 1阶 + 1阶
 *  2. 1阶 + 2阶
 *  3. 2阶 + 1阶
 * @思路
 * 到达第 i 个台阶有两种方式，从 i - 1 个台阶，爬 1 个台阶，和从 i - 2 个太接爬 2个台阶到达。所以决定爬到第 i 个台阶的方法数由到达前
 * 2 个台阶的的方法数决定，即 dp[i] = dp[i - 1] + dp[i - 2];
 */
function climbStairs(n) {
    if (n < 2) return n;
    // 1. 定义状态，确定dp含义，设定 dp[i] 表示到达第 i 个台阶的方法数
    const dp = [];
    // 2. 状态转移方程，推导递推方程，dp[i] = dp[i - 1] + dp[i - 2]
    // 3. 状态初始化，确定数组的初始化数据。到达第1个台阶有1种方法，到达第2个台阶有2种方法
    dp.push(1, 2);
    // 4. 确定遍历顺序
    for (let i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n - 1];
    // 5. 验证方程
    // 1, 2, 3
}

/**
 * 746. @使用最小花费爬楼梯
 * 给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。
 * 你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。
 * 请你计算并返回达到楼梯顶部的最低花费。
 * 输入:cost = [10, 15, 20]
 * 输出:15
 * 解释:最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。
 * 
 * @思路
 * 同爬楼梯问题，需要知道到达第 i 个台阶的方法可以从第 i - 1 和第 i - 2 个台阶到达。从描述可以知道，到达顶部时，是不需要花费的，也就是
 * 说cost[cost.length - 1]的花费是0。
 * 到达第 i 个台阶的最小花费，取决于到达第 i - 1 和第 i - 2 个台阶的最小值，如果i不是最后一个的话，那么还要最小值还要加上第i个台阶的花费
 * 也可以认为是，从第i个出发，必须要交第i个的花费。所以递推公式应该是 dp[i] = dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i]
 * 最终，只需要到大第 cost.length - 1 个或第 cost.length - 2 个台阶即可，因为下一步就是楼顶了，不需要花费了。
 */
function minCostClimbingStairs(cost) {
    // 1. 定义状态，确定dp数组的含义，dp[i] 表示到达第 i 个台阶时的花费;
    const dp = [];
    const length = cost.length;
    // 2. 状态转移方程，确定地推公式，
    // 3. 状态初始化。从题目描述中，第1个台阶的费用是必须交的，不管从到哪里，dp[0] = cost[0]，第2个台阶的费用是dp[1] = cost[1];
    dp.push(cost[0], cost[1]);
    // 4. 确定遍历顺序
    for (let i = 2; i <= length; i++) {
        dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];
    }
    return Math.min(dp[length - 1], dp[length - 2]);
}

/**
 * 路径问题。
 * 深搜、图论方法不讨论。
 */
/**
 * 62. @不同路径
 * 一个机器人位于一个 m x n 网格的左上⻆ (起始点在下图中标记为 “Start” )。
 * 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下⻆(在下图中标记为 “Finish” )。
 * 总共有多少种路径可以走？
 * @思路
 * 矩形网格中任意一点 [i][j] 的到达方式有两种（题目中给定机器人只能向下和向右走，所以不存在绕路这种方式），从 i 的上方和左方到达。所以到达第
 * [i][j] 格的路径，取决于到达第 [i-1][j] 和 第 [i][j-1]格的路径。
 * 初始化问题：需要考虑在矩形边界除的点到达方式，如果[i][j]点在顶部，即i = 0，到达 [i][j] 只有一种方式，横着过去，如果 [i][j] 点在左侧，即
 * j = 0, 到达 [i][j] 也只要一种方式，竖着向下过去。
 * 循环方向问题：只需要考虑从左上角到目标点的路径，所以从小到大遍历即可，需要注意的事，从1开始循环，因为初始化时候已经将左上角点置为1了（一种
 * 方式）。
 */
function uniquePaths(m, n) {
    // 1. 定义状态，初始化dp数组。dp为二维数组，代表第i行第j列的格
    // 2. 状态转移方程。dp[i] = dp[i - 1][j] + dp[i][j - 1];
    // 3. 状态初始化，dp[0][j] = 1; dp[i][0] = 1;
    // 4. 确定遍历顺序, i、j分别从1开始遍历;
    const dp = new Array(m).fill(0).map(_ => new Array(n).fill(0));
    for (let i = 0; i < m; i++) {
        dp[i][0] = 1; // 顶部设置为1
    }
    for (let j = 0; j < n; j++) {
        dp[0][j] = 1; // 左边设置为1
    }
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1];
}

/**
 * 63. @不同路径II
 * 一个机器人位于一个 m x n 网格的左上⻆ (起始点在下图中标记为“Start” )。
 * 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下⻆(在下图中标记为“Finish”)。
 * 现在考虑网格中有障碍物。那么从左上⻆到右下⻆将会有多少条不同的路径? 网格中的障碍物和空位置分别用 1 和 0 来表示。
 * 输入:obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
 * 输出:2
 * 3x3 网格的正中间有一个障碍物。 从左上⻆到右下⻆一共有 2 条不同的路径:
 *  1. 向右->向右->向下->向下
 *  2. 向下->向下->向右->向右
 * @思路
 * 根据62. 不同路径中的思路，对于设有障碍的方格，排除其走法即可。
 * 初始化问题：初始化时候需要注意，如果顶部和左部有障碍，那么到达障碍时，就不能往下走了。
 */
function uniquePathsWithObstacles(grids) {
    if (grids.length < 2) return 1;
    const m = grids.length;
    const n = grids[0].length;
    // 1. 定义状态，确定dp数组含义，dp[i][j] 表示达到[i][j]时的路径数
    const dp = new Array(m).fill(0).map(_ => new Array(n).fill(0));
    // 2. 确定状态转移方程，递推公式，与62相同，dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    // 3. 状态初始化, 需要注意顶部和左边的边界判断，有障碍不能设置为1
    for (let i = 0; i < m; i++) {
        if (grids[i][0] === 1) break;
        dp[i][0] = 1;
    }
    for (let j = 0; j < n; j++) {
        if (grids[0][j] === 1) break;
        dp[0][j] = 1;
    }
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            if (grids[i][j] === 1) continue;
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1];
}

/**
 * 343 @正整数拆分
 * 给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。
 * 返回 你可以获得的最大乘积。
 * 输入: n = 2
 * 输出：1
 * 解释：2 = 1 + 1, 1 × 1 = 1。
 * 输入：10
 * 输出：36
 * 解释：10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
 * @思路
 * 给定一个正整数，不知道怎么拆，是拆成 2 个，还是 x(x > 2) 个？可以假设，分两步来分析：
 *  - 将数字 n 先拆成两个，第一个是 k(k取值不确定，需要从1开始遍历)，剩余的数字是 n - k。对于乘积来说，p = k * (n - k)；
 *  - 第二个数字 n - k 是否继续拆分？如果继续拆分的话，那么我们需要提前知道 n - k 这个数字拆分后的积，
 *  - 所以 n 的取值是，Math.max(k * (n - k), k * dp[n - k])
 * 所以满足动态规划的条件。
 */
function integerBreak(n) {
    // 1. 定义状态，定义动态规划数字 dp[i] 的含义。dp[i] 标识将 n 拆成至少 2 个整数的和后，他们的乘积。
    const dp = [0, 0, 1]; // 初始化
    // 2. 确定状态转移方程，根据思路中的结论，dp[i] = Math.max(j * (i - j), j * dp[i - j]);
    // 3. 状态初始化。0 和 1 都是不可再次拆分的整数，其中 0 不是正整数，所以初始化有 dp[0] = dp[1] = 0;
    // dp[2] = 1;
    // 4. 确定遍历顺序。由于涉及到 dp[i - j]，且 i, j 都是正整数，所以 i - j 小于 i，所以从小向大遍历。
    for (let i = 3; i <= n; i++) {
        // 当前这轮最大的
        let curMax = 0;
        for (let j = 1; j < i; j++) {
            curMax = Math.max(curMax, Math.max(j * (i - j), j * dp[i - j]));
        }
        dp[i] = curMax;
    }
    return dp[n];
}
/**
 * @背包问题
 */
